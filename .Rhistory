par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
rootfun <- function(Time, State, Pars) {
dstate <- unlist(lv(Time, State, Pars))
sum(abs(dstate)) - 1e-4
}
lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
lvout=floor(lvout)
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~nrow(lvout),ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
points(lvout$P~nrow(lvout),col="red",type="line",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
lvout
plot(lvout$N~nrow(lvout),ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
plot(lvout$N~nrow(lvout))
nrow(lvout)
len(lvout$N)
length(lvout$N)
points(lvout$P~nrow(lvout),col="red",type="line",lwd=2)
plot((lvout$N)~length(lvout$N),ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
lvout
pd <- seq(.001:1,by=0.001)
# generate some d0ay of shared pathogens
test<-data.frame(pd)
head(test)
for (i in c(0.5,0.1)) {
patho <-(pd^i)/1.5
test<-cbind(test,patho)
}
plot(test[,2]~test[,1],lty=1,type="l",lwd=2,ylim=c(0,1.2),xlab="PD between hosts",ylab="phylo beta of microbial community")
plot(test[,2]~test[,1],lty=1,type="l",lwd=2,ylim=c(0,1.2),xlab="environmental distance between hosts",ylab="phylo beta of microbial community")
plot(test[,2]~test[,1],lty=1,type="l",lwd=2,ylim=c(0,1.2),xlab="geographical distance between hosts",ylab="phylo beta of microbial community")
library(slidify)
slidify("~/grad/research/exploration/lab_meeting_Dec14/lm_present.Rmd")
publish('lm_present',host = 'dropbox')
publish('lm_present',host = 'dropbox')
?publish
publish_dropbox(dirname = "~/grad/Dropbox/publish")
author("tester")
?slidify
?par
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
plot.all <- function (lvout) {}
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
points(lvout$P~time,col="red",type="line",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
plot.all <- function (lvout) {
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
points(lvout$P~time,col="red",type="line",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv,y=init,parms=params,times=time)))
lvout
plot.all(lvout)
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
plot.all(lvout)
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv_func <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
(return(list(c(dNdt,dPdt)))))
})
}
lv <- function(lv_func) {
floor(as.data.frame(lv_func)))
}
# Generate random numbers for the starting population sizes
# p<-runif(n=2,min=50,max=150)
# Set ODE parameters
# time <-seq(0,100,by=1)
# params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
plot.all <- function (lvout) {
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="l",lwd=2,col="blue")
points(lvout$P~time,col="red",type="l",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
plot.all(lvout)
scripts
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
lvout <- ode(func=lv_func,y=init,parms=params,times=time)
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
lvout
plot.all(lvout)
plot.all(lvout)
lvout
lvout
lvout
lvout
lvout
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
plot.all
source('~/.active-rstudio-document', echo=TRUE)
library(slidify)
?publish
setwd("~/grad/Dropbox/courses/fall2014/entm798v/scripts/present/")
list.files()
publish(slidify, username = getOption("gauravsk"),host="github")
publish(slidify, username = getOption("gauravsk"),host="github")
publish("slidify", username = getOption("gauravsk"),host="github")
publish("slidify", username = getOption("gauravsk"),host="github")
publish("slidify", username = getOption("gauravsk"),host="github")
publish("slidify", username = getOption("gauravsk"),host="github")
publish("slidify", username = getOption("gauravsk"),host="github")
publish(user="gauravsk",repo="slidify")
publish(user="gauravsk",repo="slidify")
