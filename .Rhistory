xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
points(lvout$P~time,col="red",type="line",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
plot.all <- function (lvout) {
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col="blue")
points(lvout$P~time,col="red",type="line",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv,y=init,parms=params,times=time)))
lvout
plot.all(lvout)
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
plot.all(lvout)
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv_func <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
(return(list(c(dNdt,dPdt)))))
})
}
lv <- function(lv_func) {
floor(as.data.frame(lv_func)))
}
# Generate random numbers for the starting population sizes
# p<-runif(n=2,min=50,max=150)
# Set ODE parameters
# time <-seq(0,100,by=1)
# params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
plot.all <- function (lvout) {
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),
xlab  ="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",
xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# add legend
# legend(x="topright",lty=c(1,2),legend=c("Species 1","Species 2"),bty="n")
# plot the starting population size
# points(x=p[1],y=p[2],cex=2,pch=20)
#
# # Set initial starting conditions for N and P, and run the ODE
# init<-c(N=p[1],P=p[2])
# lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# lvout=floor(lvout)
#########################################
# Attempting to run only to stead state #
#########################################
#
# rootfun <- function(Time, State, Pars) {
#   dstate <- unlist(lv(Time, State, Pars))
#   sum(abs(dstate)) - 1e-4
# }
# lvout<-as.data.frame(lsodar(func=lv,,y=init,parms=params,times=time,rootfun=rootfun))
# lvout=floor(lvout)
##########################################
# End attempt to run only to stead state #
##########################################
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "Species 1 vs Species 2",xlab="Species 1",
ylab="Species 2")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="l",lwd=2,col="blue")
points(lvout$P~time,col="red",type="l",lwd=2)
# legend (x =,col=c("blue","red"),lty=c(1,1),legend=c("Sp. 1", "Sp. 2"),bty="n",ncol=2)
#
#
# ## Animation
# plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
# lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
# lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
# points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#   segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#   points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#   arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#   segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#   segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#   arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
#
#   Sys.sleep(1)
#   }
#
#
#
#
#
}
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
plot.all(lvout)
scripts
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- ode(func=lv,y=init,parms=params,times=time)
lvout <- ode(func=lv_func,y=init,parms=params,times=time)
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
# run the ODE for 100 time steps
time  <- seq (0, 100, by=1)
# define species growth rates, carrying capacities and interspecific competition parameters
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
lvout
plot.all(lvout)
plot.all(lvout)
lvout
lvout
lvout
lvout
lvout
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
p <- runif(n = 2, min = 50, max = 150)
init<-c(N = floor(p[1]), P = floor (p[2]))
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout)
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
plot.all
source('~/.active-rstudio-document', echo=TRUE)
## Updated 31 Oct 2014
## Ideas:
# introduce ways to do density dependent growth of prey; (done on 31 Oct: prey_k parameter in lvpp)
# refuges for prey;
# non-type I functional response of predator
# Loess over lines so things look smooth and not step-wise
library(deSolve) # package for solving diferential equation
lvpp <- function(pp.time,pp.init,pp.params,prey_K=FALSE) {
with (as.list(c(pp.pp.time,pp.init,pp.params)), {
# Parameters
# N = prey population size; P = predator population size
# r = intrinsic growth rate of prey
# a = predation efficiency
# b = conversion efficiency of prey into predator
# d = intrinsic dseath rate of predator
# prey_k = carrying capacity for prey; only used if user-defined
if (exists("prey_k")) {
dNdt <- ((r*N)*(1-(N/prey_k)))- (a*N*P)
}
else {
dNdt <- (r*N) - (a*N*P)
}
dPdt <- (b*a*N*P) - (d*P)
return(list(c(dNdt,dPdt)))
})
}
# Set ODE parameters
# These parameters give really whacky results, should try to find better parameters for demonstration!
pp.time <-seq(0,1000,by=.1)
pp.params <- c(r=0.1,a=0.005,d=0.01,b=.1,prey_k=500)
# pp.params <- c(r=0.1,a=0.005,d=0.01,b=.1)
# Set pp.initial population sizes of Prey (N) and Predator (P)
pp.init = c(N=25,P=10)
# Run the ODE
lvout<-floor(as.data.frame(ode(func=lvpp,y=pp.init,parms=pp.params,times=pp.time)))
str (lvout)
par(mfrow=c(1,2),bg="white")
# Plot P vs N; draw in the starting N and P parameters, draw in the ZNGIs
plot(lvout$P~lvout$N,ylim=c(0,max(lvout$P)+20),type="l",xlab="Prey population size",ylab="Predator population size")
points(x=pp.init["N"],y=pp.init["P"],col="red",pch=19)
abline(v=pp.params["d"]/(pp.params["b"]*pp.params["a"]))
abline(h=pp.params["r"]/pp.params["a"])
# Plot N & P vs pp.time
plot(lvout$N~pp.time,type="l",xlab="pp.time",ylab="Population Size",ylim=c(0,max(max(lvout$N),max(lvout$P))+50))
points(lvout$P~pp.time,col="red",type="l")
legend(x="topright",col=c("black","red"),lty=1,legend=c("Prey","Predator"),bty="n")
## Updated 31 Oct 2014
## Ideas:
# introduce ways to do density dependent growth of prey; (done on 31 Oct: prey_k parameter in lvpp)
# refuges for prey;
# non-type I functional response of predator
# Loess over lines so things look smooth and not step-wise
library(deSolve) # package for solving diferential equation
lvpp <- function(pp.time,pp.init,pp.params,prey_K=FALSE) {
with (as.list(c(pp.time,pp.init,pp.params)), {
# Parameters
# N = prey population size; P = predator population size
# r = intrinsic growth rate of prey
# a = predation efficiency
# b = conversion efficiency of prey into predator
# d = intrinsic dseath rate of predator
# prey_k = carrying capacity for prey; only used if user-defined
if (exists("prey_k")) {
dNdt <- ((r*N)*(1-(N/prey_k)))- (a*N*P)
}
else {
dNdt <- (r*N) - (a*N*P)
}
dPdt <- (b*a*N*P) - (d*P)
return(list(c(dNdt,dPdt)))
})
}
# Set ODE parameters
# These parameters give really whacky results, should try to find better parameters for demonstration!
pp.time <-seq(0,1000,by=.1)
pp.params <- c(r=0.1,a=0.005,d=0.01,b=.1,prey_k=500)
# pp.params <- c(r=0.1,a=0.005,d=0.01,b=.1)
# Set pp.initial population sizes of Prey (N) and Predator (P)
pp.init = c(N=25,P=10)
# Run the ODE
lvout<-floor(as.data.frame(ode(func=lvpp,y=pp.init,parms=pp.params,times=pp.time)))
str (lvout)
par(mfrow=c(1,2),bg="white")
# Plot P vs N; draw in the starting N and P parameters, draw in the ZNGIs
plot(lvout$P~lvout$N,ylim=c(0,max(lvout$P)+20),type="l",xlab="Prey population size",ylab="Predator population size")
points(x=pp.init["N"],y=pp.init["P"],col="red",pch=19)
abline(v=pp.params["d"]/(pp.params["b"]*pp.params["a"]))
abline(h=pp.params["r"]/pp.params["a"])
# Plot N & P vs pp.time
plot(lvout$N~pp.time,type="l",xlab="pp.time",ylab="Population Size",ylim=c(0,max(max(lvout$N),max(lvout$P))+50))
points(lvout$P~pp.time,col="red",type="l")
legend(x="topright",col=c("black","red"),lty=1,legend=c("Prey","Predator"),bty="n")
lvpp <- function(pp.time,pp.init,pp.params,prey_K=FALSE) {
with (as.list(c(pp.time,pp.init,pp.params)), {
# Parameters
# N = prey population size; P = predator population size
# r = intrinsic growth rate of prey
# a = predation efficiency
# b = conversion efficiency of prey into predator
# d = intrinsic dseath rate of predator
# prey_k = carrying capacity for prey; only used if user-defined
if (exists("prey_k")) {
dNdt <- ((r*N)*(1-(N/prey_k)))- (a*N*P)
}
else {
dNdt <- (r*N) - (a*N*P)
}
dPdt <- (b*a*N*P) - (d*P)
return(list(c(dNdt,dPdt)))
})
}
pp.time <-seq(0,1000,by=.1)
pp.params <- c(r=0.1,a=0.005,d=0.01,b=.1,prey_k=500)
pp.init = c(N=25,P=10)
lvout<-floor(as.data.frame(ode(func=lvpp,y=pp.init,parms=pp.params,times=pp.time)))
library(deSolve)
lvout<-floor(as.data.frame(ode(func=lvpp,y=pp.init,parms=pp.params,times=pp.time)))
str (lvout)
par(mfrow=c(1,2),bg="white")
# Plot P vs N; draw in the starting N and P parameters, draw in the ZNGIs
plot(lvout$P~lvout$N,ylim=c(0,max(lvout$P)+20),type="l",xlab="Prey population size",ylab="Predator population size")
points(x=pp.init["N"],y=pp.init["P"],col="red",pch=19)
abline(v=pp.params["d"]/(pp.params["b"]*pp.params["a"]))
abline(h=pp.params["r"]/pp.params["a"])
# Plot N & P vs pp.time
plot(lvout$N~pp.time,type="l",xlab="pp.time",ylab="Population Size",ylim=c(0,max(max(lvout$N),max(lvout$P))+50))
points(lvout$P~pp.time,col="red",type="l")
legend(x="topright",col=c("black","red"),lty=1,legend=c("Prey","Predator"),bty="n")
```
--- bg:#404040
library(slidify)
setwd("~/grad/Dro")
setwd("~/grad/Dropbox/courses/fall2014/entm798v/")
setwd("~/grad/Dropbox/courses/fall2014/entm798v/scripts/present/")
publish(user = "gauravsk", repo = "deSolve")
publish(user = "gauravsk", repo = "deSolve")
source("~/grad/Dropbox/courses/fall2014/entm798v/scripts/R_project/lv_source.R")
init<-c(N = 199, P = 200)
time  <- seq (0, 100, by=1)
params <- c(r1 = 1, b = 1.5 , K1 = 50 , r2 = 1, a = .1 , K2 = 100)
# run the ODE
lvout <- floor(as.data.frame(ode(func=lv_func,y=init,parms=params,times=time)))
plot.all(lvout,params)
publish(user="gauravsk", repo="deSolve")
