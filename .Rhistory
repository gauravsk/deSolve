ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size")
points(lvout$P~time,col="red")
}
for (i in 1:2) {
p<-runif(n=2,min=50,max=150)
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=100,r2=1,a=1.2,K2=100)
par(mfrow=c(2,2))
# plot the Zero Net Growth Isoclines
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# Plot out the results of the ODE. First, plot NvP, then N&PvTime
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size")
points(lvout$P~time,col="red")
}
for (i in 1:2) {
p<-runif(n=2,min=50,max=150)
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=100,r2=1,a=1.2,K2=100)
par(mfrow=c(2,2))
# plot the Zero Net Growth Isoclines
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# Plot out the results of the ODE. First, plot NvP, then N&PvTime
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size")
points(lvout$P~time,col="red")
}
expression(5+10)
plot(main="expression(5+10)")
## Updated 24 Oct 2014
library(deSolve)
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp.2
# N = population size of Sp 1; P = Population Size Sp 2
# a = competitive impact of Sp 2 on Sp1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
for (i in 1:2) {
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=100,r2=1,a=1.2,K2=100)
par(mfrow=c(2,2))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size")
points(lvout$P~time,col="red")
}
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",main=expression(5+1-))
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",main=expression(5+10))
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",main=expression(beta[1]))
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",main=expression(beta[]))
?plotmaath
?plotmath
labNames <- c('xLab','yLab')
xlab <- bquote(.(labNames[1]) ~ x^2)
ylab <- bquote(.(labNames[2]) ~ y^2)
plot(c(1:10), xlab = xlab, ylab = ylab)
text(5,5, bquote(.('N1 = ',labNames[1])))
text(5,5, bquote(.('N1 = 'labNames[1])))
text(5,5, bquote(.('N1 = ' ~ labNames[1])))
?bqoute
bquote
?bquote
default <- 1
bquote( function(x, y = .(default)) x+y )
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2")
plot(1,type="n")
text(1,1,expression(N[1]))
?text
text(1,1,labels=c(expression(N[1])),100)
text(1,1,labels=c(expression(N[1])),100)
text(1,1,labels=c(expression(N[1])),paste(100))
text(1,1,labels=c((expression(N[1])),paste(100))
)
text(1,1,labels=c((expression(N[1]))," ",paste(100)))
plot(1,type="n")
text(1,1,labels=c((expression(N[1]))," ",paste(100)))
plot(1,type="n")
text(1,1,labels=c((expression(N[1])),"      ",paste(100)))
?tesst
?text
plot(1,type="n")
text(1,1,labels=c((expression(N[1])),paste(100)))
text(1,1,labels=paste(((expression(N[1])),paste(100)))
plot(1,type="n")
text(1,1,labels=paste(((expression(N[1])),paste(100)))
text(1,1,paste(expression(n[1])," ",100))
plot(1,type="n")
text(1,1,paste(expression(n[1])," ",100))
text(1,1,paste(as.expression(n[1])," ",100))
text(1,1,paste(as.expression(n[1])," ",100))
plot(1,type="n")
text(1,1,paste(as.expression(n[1])," ",100))
text(1,1,paste(as.expression("n[1]")," ",100))
text(1,1,paste(as.expression()," ",100))
expression(paste("A"[2], " and B"[2])
)
text(1,1,paste(expression(N[2])," ",100))
plot(1,type="n")
text(1,1,paste(expression(N[2]),"=",100))
text(1,1,paste(expression(N[1]),"=",100))
a <- expression(N[1])
text(1,1,paste(a,"=",100))
plot(1,type="n")
text(1,1,paste(a,"=",100))
a <- expression(N[1])
a
plot(1,type="n")
text(1,1,paste(a,"=",100))
for(i in 1:3) text(0, height[i], labels=bquote(Y[.(z2[i])] ~ "=" ~ .(z1[i])*x^2), cex=3)
z1 <- c("A","B","C")
z2 <- c("high","med","low")
height <- c(0.5,0,-0.5)
plot(0,0,type="n")
for(i in 1:3) text(0, height[i], labels=bquote(Y[.(z2[i])] ~ "=" ~ .(z1[i])*x^2), cex=3)
a <- expression(N[1] ~ 100)
plot(1,type="n")
text(1,1,labels=bquote(N[1] ~ 100))
text(1,1,labels=bquote(N[1] ~ = 100))
text(1,1,labels=bquote(N[1] ~ "=" ~ 100))
plot(1,type="n")
text(1,1,labels=bquote(N[1] ~ "=" ~ 100))
p<-c(200,100)
text(1,1,labels=bquote(N[1] ~ "=" ~ p.[1]))
text(1,1,labels=bquote(N[1] ~ "=" ~ p[1]))
plot(1,type="n")
p<-c(200,100)
text(1,1,labels=bquote(N[1] ~ "=" ~ p[1]))
text(1,1,labels=bquote(N[1] ~ "=" ~ p[.1]))
for(i in 1:3) text(0, height[i], labels=bquote(Y[.(z2[i])] ~ "=" ~ .(z1[i])*x^2), cex=3)
plot(0,0,type="n")
for(i in 1:3) text(0, height[i], labels=bquote(Y[.(z2[i])] ~ "=" ~ .(z1[i])*x^2), cex=3)
plot(1,type="n")
p<-c(200,100)
text(1,1,labels=bquote(N[1] ~ "=" ~ .(p[1])))
plot(1,type="n")
p<-c(200,100)
text(1,1,labels=bquote(N[1] == .(p[1])))
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=100,r2=1,a=1.2,K2=100)
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2)
points(lvout$P~time,col="red",type="line",lwd=2)
## Animation
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=lvout[1,2],y=lvout[1,3],cex=1,pch=20)
arrows(lvout[1,2],lvout[1,3],lvout[2,2],lvout[2,3],length=.1)
points(x=lvout[2,2],y=lvout[2,3],cex=1,pch=20)
arrows(lvout[2,2],lvout[2,3],lvout[3,2],lvout[3,3],length=.1)
for(i in 1:nrow(lvout)){arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],length=.1)}
for(i in 1:nrow(lvout)){while(floor(lvout[i,2])>0 & floor(lvout[i,3])>0){points(x=lvout[i,2],y=lvout[i,3],cex=1,pch=20)}}
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",
xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",
ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
lvout=floor(lvout)
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col=4)
points(lvout$P~time,col="red",type="line",lwd=2)
## Animation
plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
for(i in 2:nrow(lvout)){
segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
#    arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
#    arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
#    segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
#    segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
#    arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
Sys.sleep(1)
}
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=1.5,K1=50,r2=1,a=.1,K2=100)
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",
xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",
ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
lvout=floor(lvout)
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col=4)
points(lvout$P~time,col="red",type="line",lwd=2)
#
# ## Animation
#     plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
#     lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
#     lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
#     points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#     segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#     points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
# #    segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
# #    segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
# Sys.sleep(1)
#     }
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=-2,K1=10,r2=1,a=-.1,K2=10)
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",
xlim=c(0,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(0,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",
ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
lvout=floor(lvout)
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col=4)
points(lvout$P~time,col="red",type="line",lwd=2)
#
# ## Animation
#     plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
#     lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
#     lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
#     points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#     segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#     points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
# #    segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
# #    segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
# Sys.sleep(1)
#     }
## Updated 29 Oct 2014
## Ideas for improvement: clean up parameter names (consistently use N1/N2 instead of N/P); clean up color on graphs (use red/blue for isocline graph)
library(deSolve) # package for solving diferential equation
lv <- function(time,init,params) {
with (as.list(c(time,init,params)), {
# description of parameters:
# r1 = growthrate of Sp. 1; r2 = growthrate of Sp. 2
# N = population size of Sp. 1; P = Population Size Sp. 2
# a = competitive impact of Sp. 2 on Sp. 1; b = competitive impact of Sp 1 on Sp 2
# K1/K2 = carrying capacities
dNdt <- r1*N*(1-(N+a*P)/K1)
dPdt <- r2*P*(1-(P+b*N)/K2)
return(list(c(dNdt,dPdt)))
})
}
# Generate random numbers for the starting population sizes
p<-runif(n=2,min=50,max=150)
# Set ODE parameters
time <-seq(0,100,by=1)
params <- c(r1=1,b=-2,K1=10,r2=1,a=-.1,K2=10)
par(mfrow=c(2,2))
# Plot equation and parameters
plot(1:10,type="n",xlab="",ylab="",xaxt="n",yaxt="n",bty="n")
text(5,9,expression(frac(dN[1],dt) == r[1]*N[1]*bgroup("(",1-frac(N[1]+alpha*N[2],K[1]),")")))
text(3,5.7,bquote(N[1]== .(floor(p[1]))))
text(7,5.7,bquote(N[2]== .(floor(p[2]))))
text(3,4.2,bquote(r[1]== .(params["r1"])))
text(7,4.2,bquote(r[2]== .(params["r2"])))
text(3,2.7,bquote(alpha== .(params["a"])))
text(7,2.7,bquote(beta== .(params["b"])))
text(3,1.2,bquote(K[1]== .(params["K1"])))
text(7,1.2,bquote(K[2]== .(params["K2"])))
# plot the Zero Net Growth Isoclines based on parameters above.
plot(1,type="n",
xlim=c(-100,max(params["K1"],params["K2"]/params["b"])+20),
ylim=c(-100,max(params["K2"]  ,params["K1"]/params["a"])+20),xlab="Species 1",
ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i")
lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]))
lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),lty=2)
# plot the starting population size
points(x=p[1],y=p[2],cex=2,pch=20)
# Set initial starting conditions for N and P, and run the ODE
init<-c(N=p[1],P=p[2])
lvout<-as.data.frame(ode(func=lv,y=init,parms=params,times=time))
lvout=floor(lvout)
# Plot out the results of the ODE.
# First plot is for N vs P (sp1 v sp2)
plot(lvout$P~lvout$N,type="o",col="blue",xlim=c(0,max(lvout$N)+20),
ylim=c(0,max(lvout$P)+20), main = "N vs P",xlab="N", ylab="P")
# Second plot for N & P v Time
plot(lvout$N~time,ylim=c(0,max(lvout$N)+20),ylab="Population size",type="line",lwd=2,col=4)
points(lvout$P~time,col="red",type="line",lwd=2)
#
# ## Animation
#     plot(1,type="n",xlim=c(0,max(params["K1"],params["K2"]/params["b"],p[1])+20),ylim=c(0,max(params["K2"] ,params["K1"]/params["a"],p[2])+20),xlab="Species 1",ylab="Species 2",main="ZNGIs for Sp.1 and Sp.2",xaxs="i",yaxs="i",las=1)
#     lines(x=c(params["K1"],0),y=c(0,params["K1"]/params["a"]),lwd=2,col=4)
#     lines(x=c(params["K2"]/params["b"],0),y=c(0,params["K2"]),col=2,lwd=2)
#     points(x=lvout[1,2],y=lvout[1,3],cex=1.1,pch=20)
#
# for(i in 2:nrow(lvout)){
#     segments(lvout[i-1,2],lvout[i-1,3],lvout[i,2],lvout[i,3],lty=3)
#     points(x=lvout[i,2],y=lvout[i,3],cex=1.5,pch=20)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i+1,2],lvout[i,3],length=.1,col=4)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2],lvout[i+1,3],length=.1,col=2)
# #    segments(lvout[i,2],lvout[i+1,3],lvout[i+1,2],lvout[i+1,3],col=4,lty=3)
# #    segments(lvout[i+1,2],lvout[i,3],lvout[i+1,2],lvout[i+1,3],col=2,lty=3)
# #    arrows(lvout[i,2],lvout[i,3],lvout[i,2]-.9*(lvout[i,2]-lvout[i+1,2]),lvout[i,3]-.9*(lvout[i,3]-lvout[i+1,3]),length=.1)
# Sys.sleep(1)
#     }
10/-.1
2/-.2
10/-.1
setwd("~/grad//Dropbox/courses/fall2014/entm798v/scripts/")
library(slidify)
?slidify
author("mydeck")
getwd()
